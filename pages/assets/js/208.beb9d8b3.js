(window.webpackJsonp=window.webpackJsonp||[]).push([[208],{684:function(s,e,t){"use strict";t.r(e);var v=t(17),a=Object(v.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"node-js-事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js-事件循环"}},[s._v("#")]),s._v(" Node.js 事件循环")]),s._v(" "),t("ol",[t("li",[s._v("在每次执行脚本的时候，Node就开始进入事件轮询机制；")]),s._v(" "),t("li",[s._v("直到所有回调函数都被执行完成后，Node才会退出事件轮询机制；")]),s._v(" "),t("li",[s._v("Nodejs中的事件轮询机制的结构，对开发者是隐藏的，不可见的。")])]),s._v(" "),t("h2",{attrs:{id:"事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[s._v("#")]),s._v(" 事件循环")]),s._v(" "),t("p",[s._v("一个系统（或者说一个程序）中必须至少包含一个大的循环结构，它是维持系统持续运行的前提。在NodeJs中，一样也是包含这样一个循环结构，我们称之为“事件循环”，它存在于主线程中，负责不停地调用开发者编写的代码。")]),s._v(" "),t("h2",{attrs:{id:"我们其实对-node-js的单线程一直有个很深的误会"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们其实对-node-js的单线程一直有个很深的误会"}},[s._v("#")]),s._v(" 我们其实对 Node.js的单线程一直有个很深的误会")]),s._v(" "),t("p",[s._v("这里的“单线程”指的是我们（开发者）编写的代码只能运行在一个线程当中（习惯称之为主线程），Node.js并没有给 javascript 执行时创建新线程的能力，所以称为单线程，也就是所谓的主线程。 其实，Nodejs中许多异步方法在具体的实现时(NodeJs底层封装了Libuv，它提供了线程池、事件池、异步I/O等模块功能，其完成了异步方法的具体实现)，内部均采用了多线程机制。")]),s._v(" "),t("h2",{attrs:{id:"事件循环解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环解释"}},[s._v("#")]),s._v(" 事件循环解释")]),s._v(" "),t("p",[s._v("假设我们要去快餐店吃饭，有两种不同服务模式的快餐店:")]),s._v(" "),t("ul",[t("li",[s._v("一种是基于事件驱动的（我们的node服务器）")]),s._v(" "),t("li",[s._v("一种不是（像iis，apache）。")])]),s._v(" "),t("p",[s._v("对于传统的服务器，在接收到你的请求之后，直到他完成你的请求，否则他不会去接待下一个用户。当服务员输入你的订单之后还有很多事情要做，处理你的支付，帮你倒水，还有一段时间（不确定时长）去等待厨房准备好你的汉堡。服务员（相当于服务器上的线程）每次只能接待一位顾客，直到完成当前顾客的接待之后，才会去接待下一位顾客。很显然，这种方式效率不高，他浪费了太多的时间在等待厨房做汉堡的工作上。而现实中的快餐店采用的是另外一种模式，当接收到你的订单之后，他会给你一个号码牌，这个号码牌就相当于回调函数。接着他会去接待下一位顾客。当你的订餐准备好之后，服务员会呼叫你的号码叫你来取餐。这就是node采用的模式，看得出他要高效的多。")]),s._v(" "),t("p",[t("img",{attrs:{src:"/blog/img/node/event.png",alt:"img"}})]),s._v(" "),t("p",[s._v("1）NodeJs程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以NodeJs始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。")]),s._v(" "),t("p",[s._v("2）在回调函数中，可能会进行耗时的异步I/0操作，这时，NodeJs底层便会调用Libuv完成异步函数的具体实现，因此，使用回调函数处理I/O操作，并不会阻塞主程序的运行。")]),s._v(" "),t("p",[s._v("3）每次异步函数执行结束后，都会在事件队列中追加一个事件（同时，保存一些必要的参数）。事件轮询下一次循环便可取出事件，然后会调用异步方法所绑定的回调函数（因为，回调函数是绑定在事件上的，监听的事件发生，其相对应的回调函数便会被触发执行）。这样一来，nodejs便能保证开发者编写的每行代码（每个回调函数）均在主线程中执行。")]),s._v(" "),t("p",[s._v("4）需要注意的一点是： 如果开发者在回调函数中调用了阻塞方法，那么整个事件轮询就会被阻塞，事件队列中的事件便得不到及时处理。")])])}),[],!1,null,null,null);e.default=a.exports}}]);