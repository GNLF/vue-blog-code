(window.webpackJsonp=window.webpackJsonp||[]).push([[323],{782:function(s,e,a){"use strict";a.r(e);var t=a(17),n=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"处理边界情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理边界情况"}},[s._v("#")]),s._v(" 处理边界情况")]),s._v(" "),a("h2",{attrs:{id:"访问元素-访问组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问元素-访问组件"}},[s._v("#")]),s._v(" 访问元素 & 访问组件")]),s._v(" "),a("p",[s._v("在多数场景中，避免直接触及其他组件实例，或手动操作 DOM 元素，是比较推荐的做法。下面是一些需要触及的示例，最好在合适的场景才选择这种方案。")]),s._v(" "),a("h3",{attrs:{id:"访问根实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问根实例"}},[s._v("#")]),s._v(" 访问根实例")]),s._v(" "),a("p",[s._v("在由 "),a("code",[s._v("new Vue")]),s._v(" 创建出的实例下的每个子组件中，可以通过 "),a("code",[s._v("$root")]),s._v(" 属性访问根实例。举例来说，在根实例中：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Vue 根实例")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  data"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    foo"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  computed"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("bar")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* ... */")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  methods"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("baz")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* ... */")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("所有子组件中，都可以访问到此根实例，把它看作是一个全局存放的变量：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 获取根实例的数据")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("$root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("foo\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 设置根实例的数据")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("$root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 访问根实例的 computed 属性")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("$root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("bar\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 调用根实例的方法")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("$root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("baz")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("对于 demo 示例或着只有少量组件的小型应用程序来说非常方便。但是，这种模式无法很好地扩展应用到中型或大型应用程序，因此我们强烈建议，在大多数情况下使用 "),a("a",{attrs:{href:"https://github.com/vuejs/vuex",target:"_blank",rel:"noopener noreferrer"}},[s._v("Vuex"),a("OutboundLink")],1),s._v(" 来管理状态。")]),s._v(" "),a("h3",{attrs:{id:"访问父组件实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问父组件实例"}},[s._v("#")]),s._v(" 访问父组件实例")]),s._v(" "),a("p",[s._v("和 "),a("code",[s._v("$root")]),s._v(" 类似，"),a("code",[s._v("$parent")]),s._v(" 属性可以用于在子组件中访问父组件实例。这种方式可能会让你沉溺于直接触及父组件实例数据的偷懒方式，而不再使用通过 prop 传递数据。")]),s._v(" "),a("p",[s._v("在大多数情况下，触及父组件会使你的应用程序更难以调试和理解，特别是如果你在父组件中改变数据。稍后查看该组件时，会难以确定这些状态变化的来源。")]),s._v(" "),a("p",[s._v("然而，还是有一些场景（具体来说，例如需要共享的组件库），_可能_会比较适合直接访问父组件实例。例如，在一些抽象组件中，会直接与 JavaScript API 交互，而不是直接渲染 HTML，比如这些假想的 Google Maps 组件一样：")]),s._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("google-map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("google-map-markers")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("v-bind:")]),s._v("places")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')]),s._v("iceCreamShops"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("google-map-markers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("google-map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[a("code",[s._v("<google-map>")]),s._v(" 组件可能定义了所有子组件都需要访问的 "),a("code",[s._v("map")]),s._v(" 属性。在这种情况下，"),a("code",[s._v("<google-map-markers>")]),s._v(" 可能需要使用类似 "),a("code",[s._v("this.$parent.getMap")]),s._v(" 方式来获取 map 属性，以便为其添加一组标记点(marker)。"),a("a",{attrs:{href:"https://jsfiddle.net/chrisvfritz/ttzutdxh/",target:"_blank",rel:"noopener noreferrer"}},[s._v("这里"),a("OutboundLink")],1),s._v(" 你可以查看这种方式的实际情况。")]),s._v(" "),a("p",[s._v("但是请注意，以这种方式创建出来的组件，具有固有的脆弱性。例如，假想我们在这两个组件之间，添加了一个新的 "),a("code",[s._v("<google-map-region>")]),s._v(" 组件，而 "),a("code",[s._v("<google-map-markers>")]),s._v(" 放置于最内，这样就只会去渲染那个区域内的标记点：")]),s._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("google-map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("google-map-region")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("v-bind:")]),s._v("shape")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')]),s._v("cityBoundaries"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("google-map-markers")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("v-bind:")]),s._v("places")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')]),s._v("iceCreamShops"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("google-map-markers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("google-map-region")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("google-map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("然后，在 "),a("code",[s._v("<google-map-markers>")]),s._v(" 内部，你可能需要做一次 hack，这样去触及到 map 属性：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var map = this.$parent.map || this.$parent.$parent.map\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("很快代码就会一片混乱。这就是为什么要为任意深度的后代组件提供上下文信息，所以我们推荐 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/guide/components-edge-cases.html#Dependency-Injection",target:"_blank",rel:"noopener noreferrer"}},[s._v("依赖注入"),a("OutboundLink")],1),s._v(" 方式。")]),s._v(" "),a("h3",{attrs:{id:"访问子组件实例或子元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问子组件实例或子元素"}},[s._v("#")]),s._v(" 访问子组件实例或子元素")]),s._v(" "),a("p",[s._v("尽管存在 props 和事件，但有时你可能仍然需要在 JavaScript 中直接访问一个子组件。想要实现这个目的，可以使用 "),a("code",[s._v("ref")]),s._v(" 属性，来为子组件分配一个引用 ID。例如：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<base-input ref="usernameInput"></base-input>\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("现在，在这个定义过 "),a("code",[s._v("ref")]),s._v(" 的组件中，你可以调用：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("this.$refs.usernameInput\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("来访问 "),a("code",[s._v("<base-input>")]),s._v(" 实例。这种访问方式可能会很有帮助，例如，在父组件中，通过可编程方式获取子组件文本框的焦点。在这种场景中，同样的方式，在 "),a("code",[s._v("<base-input>")]),s._v(" 组件内部也使用 "),a("code",[s._v("ref")]),s._v(" 属性，来提供对于特定元素的引用，例如：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<input ref="input">\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("然后，在子组件中定义方法，以供父组件中调用：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("methods: {\n  // Used to focus the input from the parent\n  focus: function () {\n    this.$refs.input.focus()\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("这样，就可以在父组件中，获取到 "),a("code",[s._v("<base-input>")]),s._v(" 组件内部文本框的焦点：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("this.$refs.usernameInput.focus()\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("当 "),a("code",[s._v("ref")]),s._v(" 和 "),a("code",[s._v("v-for")]),s._v(" 一起使用的时候，ref 获取到的是一个包含对应数据源的子组件构成的数组。")]),s._v(" "),a("p",[a("code",[s._v("$refs")]),s._v(" 只会在组件渲染完成之后填充，并且它们不是响应式的。这意味着，它只是一个子组件封装的应急出口 - 你应该避免在模板或计算属性中访问 "),a("code",[s._v("$refs")]),s._v("。")]),s._v(" "),a("h3",{attrs:{id:"依赖注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入"}},[s._v("#")]),s._v(" 依赖注入")]),s._v(" "),a("p",[s._v("前面，我们在介绍 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B",target:"_blank",rel:"noopener noreferrer"}},[s._v("访问父组件实例"),a("OutboundLink")],1),s._v(" 时，展示过一个这样的示例：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<google-map>\n  <google-map-region v-bind:shape="cityBoundaries">\n    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>\n  </google-map-region>\n</google-map>\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("在这个组件中，所有后代 "),a("code",[s._v("<google-map>")]),s._v(" 需要访问一个 "),a("code",[s._v("getMap")]),s._v(" 方法，以便获取到要交互的 map 对象。不幸的是，在深层嵌套的组件中，使用 "),a("code",[s._v("$parent")]),s._v(" 无法很好进行扩展。这时候我们就需要用到依赖注入(dependency injection)，其中会使用两个实例选项："),a("code",[s._v("provide")]),s._v("and "),a("code",[s._v("inject")]),s._v("。")]),s._v(" "),a("p",[a("code",[s._v("provide")]),s._v(" 选项允许我们指定，我们想要提供给后代组件的数据(data)/方法(methods)。在这个示例中，我们需要提供给后代组件的是 "),a("code",[s._v("<google-map>")]),s._v(" 组件内部的 "),a("code",[s._v("getMap")]),s._v(" 方法。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("provide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("然后，在所有后代组件中，我们可以使用 "),a("code",[s._v("inject")]),s._v(" 选项，来接收那些我们需要添加到当前实例中的特定属性：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("inject: ['getMap']\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("你可以在 "),a("a",{attrs:{href:"https://jsfiddle.net/chrisvfritz/tdv8dt3s/",target:"_blank",rel:"noopener noreferrer"}},[s._v("这里查看完整示例"),a("OutboundLink")],1),s._v("。相比直接引用 "),a("code",[s._v("$parent")]),s._v(" 的优势在于，我们可以在_任何_一个后代组件中，直接访问 "),a("code",[s._v("getMap")]),s._v(" 方法，无须暴露整个 "),a("code",[s._v("<google-map>")]),s._v(" 实例。这可以使我们更加安全地继续开发该组件，而不必担心可能会修改或移除子组件所依赖的祖先组件中的内容。这些组件之间的接口保持着清晰的定义，就像是 "),a("code",[s._v("props")]),s._v(" 一样。")]),s._v(" "),a("p",[s._v("事实上，你可以把依赖注入看作一组 “扩大范围的 props”，以下情况使用依赖注入：")]),s._v(" "),a("ul",[a("li",[s._v("祖先组件不需要知道哪些后代组件使用它提供的属性")]),s._v(" "),a("li",[s._v("后代组件不需要知道被注入的属性来自何处")])]),s._v(" "),a("p",[s._v("然而，依赖注入还是有缺陷的。它将子组件与你应用程序当前组织方式耦合起来，使得重构变得更加困难。提供的属性也不是响应式的。这是出于设计考虑，因为使用它们来创建一个中心化数据仓库，和 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E6%A0%B9%E5%AE%9E%E4%BE%8B",target:"_blank",rel:"noopener noreferrer"}},[s._v("使用 "),a("code",[s._v("$root")]),a("OutboundLink")],1),s._v(" 本质相同，都会难以维护。如果想要共享的属性，不是普通属性，而是应用程序级别的特定属性，或者希望想要祖先组件内部修改提供的数据，而后代组件响应式的更新，那么，你就需要使用一个真正的状态管理解决方案，就像 "),a("a",{attrs:{href:"https://github.com/vuejs/vuex",target:"_blank",rel:"noopener noreferrer"}},[s._v("Vuex"),a("OutboundLink")],1),s._v(" 这样的状态管理库。")]),s._v(" "),a("p",[s._v("在 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/api/#provide-inject",target:"_blank",rel:"noopener noreferrer"}},[s._v("API 参考文档"),a("OutboundLink")],1),s._v(" 中，了解更多关于依赖注入的知识。")]),s._v(" "),a("h2",{attrs:{id:"可编程的事件监听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可编程的事件监听器"}},[s._v("#")]),s._v(" 可编程的事件监听器")]),s._v(" "),a("p",[s._v("到目前为止，你已经学会使用 "),a("code",[s._v("$emit")]),s._v("，并且知道使用 "),a("code",[s._v("v-on")]),s._v(" 监听它触发的事件，但是 Vue 实例还在其事件接口中提供了其他方法。我们可以：")]),s._v(" "),a("ul",[a("li",[s._v("使用 "),a("code",[s._v("$on(eventName, eventHandler)")]),s._v(" 监听一个事件")]),s._v(" "),a("li",[s._v("使用 "),a("code",[s._v("$once(eventName, eventHandler)")]),s._v(" 一次性地监听一个事件")]),s._v(" "),a("li",[s._v("使用 "),a("code",[s._v("$off(eventName, eventHandler)")]),s._v(" 停止监听一个事件")])]),s._v(" "),a("p",[s._v("通常不需要用到这些可编程的事件监听器，但是它们可用于这种情况，就是当你需要手动监听组件实例上的事件时。还可以用作代码组织工具。例如，你可能经常会看到这种集成第三方库的用法：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 在挂载到 DOM 时，将日期选择器插件\n// 应用到一个文本框上\nmounted: function () {\n  // Pikaday 是一个第三方日期选择器插件库\n  this.picker = new Pikaday({\n    field: this.$refs.input,\n    format: 'YYYY-MM-DD'\n  })\n},\n// 在组件被销毁之前，\n// 也销毁日期选择器。\nbeforeDestroy: function () {\n  this.picker.destroy()\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("这里会有两个潜在的问题：")]),s._v(" "),a("ul",[a("li",[s._v("需要在组件实例中保存此 "),a("code",[s._v("picker")]),s._v(" 实例，然而，只有生命周期钩子才可能需要访问它。这并不算严重的问题，只是多余出一个 picker 实例属性。")]),s._v(" "),a("li",[s._v("我们的安装代码与清理代码彼此分离，这会使以编程方式清理我们设置的任何内容时，变得更加困难。")])]),s._v(" "),a("p",[s._v("你应该通过一个可编程的事件监听器，来解决这两个问题：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("mounted: function () {\n  var picker = new Pikaday({\n    field: this.$refs.input,\n    format: 'YYYY-MM-DD'\n  })\n\n  this.$once('hook:beforeDestroy', function () {\n    picker.destroy()\n  })\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("使用这种策略，我们甚至可以将 Pikaday 应用到多个输入框元素，每个新的实例都会在钩子触发后自动清理自身：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("mounted: function () {\n  this.attachDatepicker('startDateInput')\n  this.attachDatepicker('endDateInput')\n},\nmethods: {\n  attachDatepicker: function (refName) {\n    var picker = new Pikaday({\n      field: this.$refs[refName],\n      format: 'YYYY-MM-DD'\n    })\n\n    this.$once('hook:beforeDestroy', function () {\n      picker.destroy()\n    })\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("请在 "),a("a",{attrs:{href:"https://jsfiddle.net/chrisvfritz/1Leb7up8/",target:"_blank",rel:"noopener noreferrer"}},[s._v("fiddle"),a("OutboundLink")],1),s._v(" 中查看完整示例代码。注意，即使我们提供了这种策略，如果你发现自己必须在单个组件中完成大量安装和清理工作，最佳解决方案通常还是创建出更加模块化的组件。在这种情况下，我们建议你将这些代码抽离，创建出一个可复用的 "),a("code",[s._v("<input-datepicker>")]),s._v(" 组件。")]),s._v(" "),a("p",[s._v("想要了解更多可编程事件监听器的内容，请查看 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[s._v("实例方法 / 事件"),a("OutboundLink")],1),s._v(" 相关的 API。")]),s._v(" "),a("p",[s._v("注意，Vue 事件系统与浏览器中的 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget",target:"_blank",rel:"noopener noreferrer"}},[s._v("EventTarget API"),a("OutboundLink")],1),s._v(" 不同。尽管它们之间运行机制类似，但是 "),a("code",[s._v("$emit")]),s._v(", "),a("code",[s._v("$on")]),s._v(" 和 "),a("code",[s._v("$off")]),s._v(" "),a("strong",[s._v("并不是")]),s._v(" "),a("code",[s._v("dispatchEvent")]),s._v(", "),a("code",[s._v("addEventListener")]),s._v(" 和 "),a("code",[s._v("removeEventListener")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"循环引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环引用"}},[s._v("#")]),s._v(" 循环引用")]),s._v(" "),a("h3",{attrs:{id:"递归组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归组件"}},[s._v("#")]),s._v(" 递归组件")]),s._v(" "),a("p",[s._v("组件可以在它本身的模板中，递归地调用自身。但是，只有具有 "),a("code",[s._v("name")]),s._v(" 选项时，才能这么做：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("name: 'unique-name-of-my-component'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("在使用 "),a("code",[s._v("Vue.component")]),s._v(" 全局注册一个组件时, 组件的全局 ID 会被自动设置为其 "),a("code",[s._v("name")]),s._v(" 选项。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Vue.component('unique-name-of-my-component', {\n  // ...\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("如果你不够小心谨慎, 递归组件可能会导致无限循环:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("name: 'stack-overflow',\ntemplate: '<div><stack-overflow></stack-overflow></div>'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("类似如上所示的组件，会导致一个 “max stack size exceeded(超出最大调用栈大小)” 错误，因此，确保递归调用具有终止条件（例如，使用最终会得到 "),a("code",[s._v("false")]),s._v(" 的 "),a("code",[s._v("v-if")]),s._v("）。")]),s._v(" "),a("h3",{attrs:{id:"组件之间的循环引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件之间的循环引用"}},[s._v("#")]),s._v(" 组件之间的循环引用")]),s._v(" "),a("p",[s._v("假设你正在创建一个文件目录树，就像是 Mac 下的 Finder 或是 Windows 下的文件资源管理器。你可能有一个使用如下模板的 "),a("code",[s._v("tree-folder")]),s._v(" 组件：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<p>\n  <span>{{ folder.name }}</span>\n  <tree-folder-contents :children="folder.children"/>\n</p>\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("然后，有一个使用如下模板的 "),a("code",[s._v("tree-folder-contents")]),s._v(" 组件：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<ul>\n  <li v-for="child in children">\n    <tree-folder v-if="child.children" :folder="child"/>\n    <span v-else>{{ child.name }}</span>\n  </li>\n</ul>\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("仔细观察后，你就会发现：在渲染树中，这些组件实际上都是彼此的_后代_和_祖先_，这是矛盾且相悖的！在使用 "),a("code",[s._v("Vue.component")]),s._v(" 全局注册组件时，这个问题会自动解决。如果以上已经解决你的问题，你可以在这里停止阅读。")]),s._v(" "),a("p",[s._v("然而，如果你使用了"),a("strong",[s._v("模块系统")]),s._v("（例如通过 webpack 或 Browserify 等打包工具），并通过 require/import 导入组件的话，你就会看到一个错误：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Failed to mount component: template or render function not defined.\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("为了解释这是如何产生的，我们可以将组件称为 A 和 B。模块系统看到它需要导入 A，但是首先 A 需要导入 B，但是 B 又需要导入 A，A 又需要导入 B，等等，如此形成了一个死循环，模块系统并不知道如何在先不解析一个组件的情况下，完全解析另外一个组件。为了修复这个问题，我们需要给模块系统一个切入点，我们可以告诉它，A 需要导入 B，但是没有必要先解析 B。")]),s._v(" "),a("p",[s._v("在这种场景中，将 "),a("code",[s._v("tree-folder")]),s._v(" 组件做为切入点。我们知道制造矛盾的是 "),a("code",[s._v("tree-folder-contents")]),s._v(" 子组件，所以，我们需要在 "),a("code",[s._v("tree-folder")]),s._v(" 组件的 "),a("code",[s._v("beforeCreate")]),s._v("这一生命周期钩子函数中，去注册 "),a("code",[s._v("tree-folder-contents")]),s._v(" 组件：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("beforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("或者，还可以在局部注册组件时，使用 webpack 提供的异步 "),a("code",[s._v("import")]),s._v("，")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("components: {\n  TreeFolderContents: () => import('./tree-folder-contents.vue')\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("这样问题就解决了！")]),s._v(" "),a("h2",{attrs:{id:"模板定义的其他替代方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板定义的其他替代方式"}},[s._v("#")]),s._v(" 模板定义的其他替代方式")]),s._v(" "),a("h3",{attrs:{id:"内联模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内联模板"}},[s._v("#")]),s._v(" 内联模板")]),s._v(" "),a("p",[s._v("当子组件具有 "),a("code",[s._v("inline-template")]),s._v(" 特性时，这个组件会把它内部的内容当作它的模板，而不是把这些内部内容当作分发内容。这会使模板编写更加灵活。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("<my-component inline-template>\n  <div>\n    <p>这些内容会被编译为组件自身的模板。</p>\n    <p>而不是父组件输送的分发内容。</p>\n  </div>\n</my-component>\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("但是，"),a("code",[s._v("inline-template")]),s._v(" 会使模板的作用域变得难以推测。所以最佳实践还是在组件内部使用 "),a("code",[s._v("template")]),s._v(" 选项来定义模板，或者在 "),a("code",[s._v(".vue")]),s._v(" 文件中，定义一个 "),a("code",[s._v("<template>")]),s._v(" 元素。")]),s._v(" "),a("h3",{attrs:{id:"x-templates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#x-templates"}},[s._v("#")]),s._v(" X-Templates")]),s._v(" "),a("p",[s._v("另一种定义模板的方式是，使用一个 type 为 "),a("code",[s._v("text/x-template")]),s._v(" 的 script 元素，然后通过一个 id 来引用这个模板。例如：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n<\/script>\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("这种方式适用于具有较多模板内容的演示示例，或者用于小型应用程序，但是在其他情况下应该避免使用，因为这会把模板从组件定义的其他选项中脱离出来。")]),s._v(" "),a("h2",{attrs:{id:"控制更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制更新"}},[s._v("#")]),s._v(" 控制更新")]),s._v(" "),a("p",[s._v("感谢 Vue 的响应式系统，（如果你能够正确使用，）它会始终知道进行更新的正确时机。不过，还是有些边界情况，即使事实上响应式数据并没有发生变化，你都需要强制更新。并且还有一些其他情况，你可能想要阻止不必要的更新。")]),s._v(" "),a("h3",{attrs:{id:"强制一次更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强制一次更新"}},[s._v("#")]),s._v(" 强制一次更新")]),s._v(" "),a("p",[s._v("如果你发现自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。")]),s._v(" "),a("p",[s._v("你可能还没有留意到 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-Caveats",target:"_blank",rel:"noopener noreferrer"}},[s._v("数组"),a("OutboundLink")],1),s._v(" 或 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-Object-Change-Detection-Caveats",target:"_blank",rel:"noopener noreferrer"}},[s._v("对象"),a("OutboundLink")],1),s._v(" 的变化检测注意事项，或者，你可能依赖了一个未被 Vue 响应式系统追踪的状态（例如 "),a("code",[s._v("data")]),s._v(" 中的非响应式状态）。")]),s._v(" "),a("p",[s._v("如果你已遵循上述注意事项，但是发现在极少数的情况下，仍然需要手动强制更新，这时候你可以通过 "),a("a",{attrs:{href:"https://vue.docschina.org/v2/api/#vm-forceUpdate",target:"_blank",rel:"noopener noreferrer"}},[a("code",[s._v("$forceUpdate")]),a("OutboundLink")],1),s._v(" 来实现。")]),s._v(" "),a("h3",{attrs:{id:"使用-v-once-创建低开销的静态组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-v-once-创建低开销的静态组件"}},[s._v("#")]),s._v(" 使用 "),a("code",[s._v("v-once")]),s._v(" 创建低开销的静态组件")]),s._v(" "),a("p",[s._v("尽管通过 Vue 来渲染普通的 HTML 元素非常快速，不过有时你或许会有一个包含"),a("strong",[s._v("大量")]),s._v("静态内容的组件。在这种情况下，你可以在根元素上添加 "),a("code",[s._v("v-once")]),s._v(" 指令，来确保这些静态内容只做一次取值后就缓存起来，就像这样：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Vue.component('terms-of-service', {\n  template: `\n    <div v-once>\n      <h1>服务条款</h1>\n      …… 大量静态内容 ……\n    </div>\n  `\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("再次声明，尽量不要过度使用这种方式。虽然在必须渲染大量静态内容这种极少数的情况下时，使用这种方式会很方便，但是除非你能够确切感受到渲染速度变慢，否则这种方式完全是没有必要的 - 再加上它在后期会带来很多困惑。例如，设想有其他不熟悉 "),a("code",[s._v("v-once")]),s._v(" 的开发者，或熟悉但是忽略了模板中 "),a("code",[s._v("v-once")]),s._v(" 指令。他们可能会消耗数个小时，去找出模板无法正确更新的原因。")])])}),[],!1,null,null,null);e.default=n.exports}}]);