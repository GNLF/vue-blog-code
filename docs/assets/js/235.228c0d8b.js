(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{710:function(s,e,a){"use strict";a.r(e);var t=a(17),n=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[s._v("#")]),s._v(" JWT")]),s._v(" "),a("blockquote",[a("p",[s._v("JWT——Json web token")])]),s._v(" "),a("p",[s._v("JWT——Json web token 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准，可实现无状态、分布式的Web应用授权。")]),s._v(" "),a("h2",{attrs:{id:"我们为什么需要jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们为什么需要jwt"}},[s._v("#")]),s._v(" 我们为什么需要JWT？")]),s._v(" "),a("p",[s._v("首先，当前后端分离时我们会因为同源策略而无法设置cookie和sessionid。当然了我们有很多方式去解决这个问题，比如反向代理和jsonp等。但这仍然不如直接使用jwt来的简便。其次就是要说到jwt与传统的身份认证相比有什么优势了。")]),s._v(" "),a("p",[s._v("回答这个问题需要来看看基于token的认证和传统的session认证的区别")]),s._v(" "),a("h3",{attrs:{id:"传统的session认证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传统的session认证"}},[s._v("#")]),s._v(" 传统的session认证")]),s._v(" "),a("p",[s._v("我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。")]),s._v(" "),a("p",[s._v("但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.")]),s._v(" "),a("h3",{attrs:{id:"基于token的鉴权机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于token的鉴权机制"}},[s._v("#")]),s._v(" 基于token的鉴权机制")]),s._v(" "),a("p",[s._v("基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。")]),s._v(" "),a("p",[s._v("流程上是这样的：")]),s._v(" "),a("ol",[a("li",[s._v("用户使用用户名密码来请求服务器")]),s._v(" "),a("li",[s._v("服务器进行验证用户的信息 服务器通过验证发送给用户一个token")]),s._v(" "),a("li",[s._v("客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据")]),s._v(" "),a("li",[s._v("这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了"),a("code",[s._v("Access-Control-Allow-Origin:*")]),s._v("。")])]),s._v(" "),a("p",[s._v("也就是说相比于传统基于cookie的session，基于token的jwt有以下优点：")]),s._v(" "),a("ul",[a("li",[s._v("Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.")]),s._v(" "),a("li",[s._v("无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.")]),s._v(" "),a("li",[s._v("更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.")]),s._v(" "),a("li",[s._v("去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.")]),s._v(" "),a("li",[s._v("更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。")]),s._v(" "),a("li",[s._v("CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。")]),s._v(" "),a("li",[s._v("性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.")]),s._v(" "),a("li",[s._v("不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.")]),s._v(" "),a("li",[s._v("基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.")])]),s._v(" "),a("h2",{attrs:{id:"json-web-token-jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-web-token-jwt"}},[s._v("#")]),s._v(" Json Web Token（JWT）")]),s._v(" "),a("p",[s._v("JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：")]),s._v(" "),a("ul",[a("li",[s._v("简洁(Compact)\n可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快")]),s._v(" "),a("li",[s._v("自包含(Self-contained)\n负载中包含了所有用户所需要的信息，避免了多次查询数据库")])]),s._v(" "),a("h3",{attrs:{id:"jwt-组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jwt-组成"}},[s._v("#")]),s._v(" JWT 组成")]),s._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/node/jwtzucheng.jpg",alt:"img"}})]),s._v(" "),a("h4",{attrs:{id:"header-头部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#header-头部"}},[s._v("#")]),s._v(" Header 头部")]),s._v(" "),a("p",[s._v("头部包含了两部分，token 类型和采用的加密算法")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用Node.js，可以用Node.js的包base64url来得到这个字符串。")]),s._v(" "),a("blockquote",[a("p",[s._v("Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。")])]),s._v(" "),a("h4",{attrs:{id:"payload-负载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#payload-负载"}},[s._v("#")]),s._v(" Payload 负载")]),s._v(" "),a("p",[s._v("这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('{\n    "iss": "lion1ou JWT",\n    "iat": 1441593502,\n    "exp": 1441594722,\n    "aud": "www.example.com",\n    "sub": "lion1ou@163.com"\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("同样的，它会使用 Base64 编码组成 JWT 结构的第二部分")]),s._v(" "),a("h4",{attrs:{id:"signature-签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signature-签名"}},[s._v("#")]),s._v(" Signature 签名")]),s._v(" "),a("p",[s._v("前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。")]),s._v(" "),a("p",[s._v("三个部分通过.连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。")]),s._v(" "),a("ul",[a("li",[s._v("签名的目的\n最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。")]),s._v(" "),a("li",[s._v("信息暴露\n在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？")])]),s._v(" "),a("p",[s._v("是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。")]),s._v(" "),a("p",[s._v("因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。")]),s._v(" "),a("h2",{attrs:{id:"如何使用jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何使用jwt"}},[s._v("#")]),s._v(" 如何使用jwt")]),s._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/node/jwtrenzheng.jpg",alt:"img"}})]),s._v(" "),a("ol",[a("li",[s._v("首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。")]),s._v(" "),a("li",[s._v("后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。")]),s._v(" "),a("li",[s._v("后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。")]),s._v(" "),a("li",[s._v("前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)")]),s._v(" "),a("li",[s._v("后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。")]),s._v(" "),a("li",[s._v("验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。")])]),s._v(" "),a("h3",{attrs:{id:"和session方式存储id的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和session方式存储id的差异"}},[s._v("#")]),s._v(" 和Session方式存储id的差异")]),s._v(" "),a("p",[s._v("Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。")]),s._v(" "),a("p",[s._v("而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话。")]),s._v(" "),a("h3",{attrs:{id:"单点登录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单点登录"}},[s._v("#")]),s._v(" 单点登录")]),s._v(" "),a("p",[s._v("Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。 安装方式：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//--save是否需要取决于你是否需要把安装版本写进package.json\nnpm install --save jwt-simple\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("使用方式")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var jwt = require('jwt-simple');\nvar payload = { foo: 'bar' };\nvar secret = 'xxx';\n\n// HS256 secrets are typically 128-bit random strings, for example hex-encoded:\n// var secret = Buffer.from('fe1a1915a379f3be5394b64d14794932', 'hex)\n\n// encode\nvar token = jwt.encode(payload, secret);\n\n// decode\nvar decoded = jwt.decode(token, secret);\nconsole.log(decoded); //=> { foo: 'bar' }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("注意secret是用于解密的密文，是必须保存在服务器端。")]),s._v(" "),a("h2",{attrs:{id:"认证过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#认证过程"}},[s._v("#")]),s._v(" 认证过程")]),s._v(" "),a("p",[s._v("下面我们从一个实例来看如何运用JWT机制实现认证：")]),s._v(" "),a("p",[s._v("登录")]),s._v(" "),a("ol",[a("li",[s._v("第一次认证：第一次登录，用户从浏览器输入用户名/密码，提交后到服务器的登录处理的Action层（Login Action）；")]),s._v(" "),a("li",[s._v("Login Action调用认证服务进行用户名密码认证，如果认证通过，Login Action层调用用户信息服务获取用户信息（包括完整的用户信息及对应权限信息）；")]),s._v(" "),a("li",[s._v("返回用户信息后，Login Action从配置文件中获取Token签名生成的秘钥信息，进行Token的生成；")]),s._v(" "),a("li",[s._v("生成Token的过程中可以调用第三方的JWT Lib生成签名后的JWT数据；")]),s._v(" "),a("li",[s._v("完成JWT数据签名后，将其设置到COOKIE对象中，并重定向到首页，完成登录过程；")])]),s._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/node/token-login.jpg",alt:"img"}})]),s._v(" "),a("p",[s._v("请求认证")]),s._v(" "),a("p",[s._v("基于Token的认证机制会在每一次请求中都带上完成签名的Token信息，这个Token信息可能在COOKIE中，也可能在HTTP的Authorization头中；")]),s._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/node/token-login2.jpg",alt:"img"}})]),s._v(" "),a("ul",[a("li",[s._v("客户端（APP客户端或浏览器）通过GET或POST请求访问资源（页面或调用API）；")]),s._v(" "),a("li",[s._v("认证服务作为一个Middleware HOOK 对请求进行拦截，首先在cookie中查找Token信息，如果没有找到，则在HTTP Authorization Head中查找；")]),s._v(" "),a("li",[s._v("如果找到Token信息，则根据配置文件中的签名加密秘钥，调用JWT Lib对Token信息进行解密和解码；")]),s._v(" "),a("li",[s._v("完成解码并验证签名通过后，对Token中的exp、nbf、aud等信息进行验证；")]),s._v(" "),a("li",[s._v("全部通过后，根据获取的用户的角色权限信息，进行对请求的资源的权限逻辑判断；")]),s._v(" "),a("li",[s._v("如果权限逻辑判断通过则通过Response对象返回；否则则返回HTTP 401；")])])])}),[],!1,null,null,null);e.default=n.exports}}]);