# Vue3.0

## 新特性

### 性能更快

> Performance：性能比Vue2.x快1.2~2倍

#### 1. 使用Proxy代替defineProperty实现数据响应式

#### 2. diff 算法优化

1. vue2中的虚拟dom是进行全量的对比

2. Vue3新增了静态标记(prefix identifiers -- 前缀标识符),在与上次虚拟节点进行对比时，只对比带有PatchFlag的节点，并且可以通过flag的信息得知当前节点要对比的具体内容

   ```html
   <div>
     	<p>HelloWorld</p>
       <p>HelloWorld</p>
       <p>HelloWorld</p>
       <p>HelloWorld</p>
       <p>{{ username }}</p>
       <p v-html="age"></p>
       <p @click="handler">handler</p>
   </div>
   ```

   ```js
   import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from "vue"
   
   export function render(_ctx, _cache, $props, $setup, $data, $options) {
     return (_openBlock(), _createBlock("div", null, [
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, _toDisplayString(_ctx.username), 1 /* TEXT */),
       _createVNode("p", { innerHTML: _ctx.age }, null, 8 /* PROPS */, ["innerHTML"]),
       _createVNode("p", { onClick: _ctx.handler }, "handler", 8 /* PROPS */, ["onClick"])
     ]))
   }
   ```

#### 3. hoistStatic 静态提升

1. Vue2中无论元素是否参与更新,每次都会重新创建

2. Vue3中对于不参与更新的元素,只会被创建一次,之后会在每次渲染时,都会复用

   ```js
   import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from "vue"
   
   const _hoisted_1 = /*#__PURE__*/_createVNode("p", null, "HelloWorld", -1 /* HOISTED */)
   const _hoisted_2 = /*#__PURE__*/_createVNode("p", null, "HelloWorld", -1 /* HOISTED */)
   const _hoisted_3 = /*#__PURE__*/_createVNode("p", null, "HelloWorld", -1 /* HOISTED */)
   const _hoisted_4 = /*#__PURE__*/_createVNode("p", null, "HelloWorld", -1 /* HOISTED */)
   
   export function render(_ctx, _cache, $props, $setup, $data, $options) {
     return (_openBlock(), _createBlock("div", null, [
       _hoisted_1,
       _hoisted_2,
       _hoisted_3,
       _hoisted_4,
       _createVNode("p", null, _toDisplayString(_ctx.username), 1 /* TEXT */),
       _createVNode("p", { innerHTML: _ctx.age }, null, 8 /* PROPS */, ["innerHTML"]),
       _createVNode("p", { onClick: _ctx.handler }, "handler", 8 /* PROPS */, ["onClick"])
     ]))
   }
   
   ```

   

#### 4. CacheHandlers 事件侦听器缓存

1. 默认情况下onClick会被视为动态绑定,所以每次都会去追踪它的变化,但是因为是同一个函数,所以没有追踪变化,直接缓存起来复用即可

   ```js
   import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from "vue"
   
   export function render(_ctx, _cache, $props, $setup, $data, $options) {
     return (_openBlock(), _createBlock("div", null, [
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, "HelloWorld"),
       _createVNode("p", null, _toDisplayString(_ctx.username), 1 /* TEXT */),
       _createVNode("p", { innerHTML: _ctx.age }, null, 8 /* PROPS */, ["innerHTML"]),
       _createVNode("p", {
         onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.handler(...args)))
       }, "handler")
     ]))
   }
   ```

   

#### 5. SSR渲染

1. 当有大量静态的内容时,这些内容会被当做纯字符串推进一个buffer里面,即使存在动态的绑定,会通过模版插值嵌入进去,这样会比通过虚拟DOM来渲染的快很多很多

2. 当静态内容大到一定量级时候,会用_createStaticVNode方法在客户端去生成一个static node,这些静态node,会被直接innerHtml,就不需要创建对象,然后根据对象渲染.

   ```js
   import { mergeProps as _mergeProps } from "vue"
   import { ssrResolveCssVars as _ssrResolveCssVars, ssrRenderAttrs as _ssrRenderAttrs, ssrInterpolate as _ssrInterpolate } from "@vue/server-renderer"
   
   export function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
     const _cssVars = _ssrResolveCssVars({ color: _ctx.color })
     _push(`<div${
       _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))
     }><p>HelloWorld</p><p>HelloWorld</p><p>HelloWorld</p><p>HelloWorld</p><p>${
       _ssrInterpolate(_ctx.username)
     }</p><p>${
       _ctx.age
     }</p><p>handler</p></div>`)
   }
   ```

   

### 体积小

Tree shaking support：按需编译，体积比Vue2.x更小



### 组合API

- Composition API：组合API（类似React Hooks）

- setup
  - ref 和 reactive
  - computed 和 watch
  - 新的生命周期函数
  - provide与inject
  - ...

 

### 更好地支持TS

Better TypeScript support：更好的Ts支持



### 自定义渲染API

Customer Render API：暴露了自定义渲染API



### 更先进的组件

- Fragment ------- 文档碎片
- Teleport(Protal) ------ 瞬移组件的位置
- Suspense ------ 异步加载组件的loading界面 